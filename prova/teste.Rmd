---
title: "Resolução da Prova PGMAT0061"
author: "Gerson Primo Jr"
date: "2025-02-05"
output: html_document
--- 
> Pacotes necessários para a execução do código
```{r}
#install.packages(c("purrr", "ggplot2", "glue", "MASS"))
library(ggplot2)
library(purrr)
library(MASS)
```

### Questão 1.  
Escreva um algoritimo de simulação para gerar valores

#### a) Distribuição Bell-Touchard

A variável aleatória \( X \) possui função massa de probabilidade dada por:

\[
P(X = x) = \frac{e^{\theta (1 - e^{-\alpha})} \alpha^x T_x(\theta)}{x!}, \quad x = 0, 1, 2, \dots
\]

onde \( T_x(\theta) \) são os polinômios de Touchard definidos por:

\[
T_x(\theta) = e^{-\theta} \sum_{k=0}^{\infty} \frac{k^x \theta^k}{k!}
\]

##### Código em R

```{r}
# Função para calcular o polinômio de Touchard
tx <- function(x, theta, max_k = 100) {
  k <- 0:max_k
  terms <- (k^x) * (theta^k) / factorial(k)
  return(exp(-theta) * sum(terms))
}

# Função de massa de probabilidade (PMF)
fx <- function(x, alpha, theta) {
  Tx <- tx(x, theta)
  return((exp(theta * (1 - exp(-alpha))) * (alpha^x) * Tx) / factorial(x))
}

# Método da inversão discreto
gerar_amostra <- function(alpha, theta, max_x = 50) {
  px <- purrr::map_dbl(0:max_x, ~ fx(.x, alpha, theta))
  Fx <- cumsum(px)
  Fx <- Fx / max(Fx)
  u <- runif(1)
  x <- purrr::detect_index(Fx, ~ u <= .x) - 1
  return(x)
}

# Exemplo de uso
alpha <- 1.0
theta <- 2.0
n = 100
x <- purrr::map_int(1:n, ~ gerar_amostra(alpha, theta))

# Criar histograma com alinhamento correto
hist(x, probability = TRUE, breaks = seq(-0.5, max(x) + 0.5, by = 1), 
     main = "Histograma e Curva da Distribuição Bell-Touchard", 
     xlab = "x", ylab = "Densidade", col = "lightblue", border = "black")

# Plotar a curva da distribuição sobre o histograma
max_x <- max(x)
p_x <- purrr::map_dbl(0:max_x, ~ fx(.x, alpha, theta))
df <- data.frame(x = 0:max_x, y = p_x)

# Adicionar pontos e linhas para a PMF
points(df$x, df$y, col = "red", pch = 19)
lines(df$x, df$y, col = "red", lwd = 2)
```

---

#### Questão 2. Estimativa Monte Carlo da Integral
```{r}
m <- 10000
x <- runif(m)
y <- runif(m)
z <- runif(m)

f_xyz <- y * cos(pi * y) * exp(-x^2 - z^2)

estimativa <- mean(f_xyz)

# Intervalo de confiança a 98%
se <- sd(f_xyz) / sqrt(m)
z_crit <- qnorm(0.99)
IC <- c(estimativa - z_crit * se, estimativa + z_crit * se)

list(estimativa = estimativa, intervalo = IC)
```

---

#### Questão 3. Simulação do experimento
```{r}
simular_experimento <- function() {
  moeda <- sample(c("cara", "coroa"), 1, prob = c(2/3, 1/3))
  urna <- ifelse(moeda == "cara", c(rep("amarela", 3), rep("azul", 2)), 
                                      c(rep("amarela", 2), rep("azul", 4)))
  bola <- sample(urna, 1)
  
  if (bola == "amarela") {
    return(rpois(1, 2) + 1)
  } else {
    gumbel_sample <- rgumbel(2, loc = c(5, 7), scale = c(1, exp(1)))
    return(sum(gumbel_sample))
  }
}

set.seed(42)
simulacoes <- replicate(25, simular_experimento())
print(simulacoes)
```

---

#### Questão 4. Aproximação de \(\text{Corr}(U, 1-U^2)\)
```{r}
m <- 10000
U <- runif(m)
V <- 1 - U^2
correlacao <- cor(U, V)
correlacao
```

---

Agora o documento contém todas as resoluções necessárias. Caso precise de ajustes, me avise!
