---
title: "Resolu√ß√£o da Prova PGMAT0061"
author: "Gerson Primo Jr"
date: "2025-02-05"
output: html_document
---

# 


```{r, warning=FALSE, message=FALSE, echo=TRUE}
# ##### Pacotes necess√°rios para a execu√ß√£o do c√≥digo
instalar_pkt <- function(pacotes) {
  instalados <- pacotes %in% installed.packages()[, "Package"]
  if (any(!instalados)) install.packages(pacotes[!instalados])
}

instalar_pkt(c("purrr", "ggplot2", "glue", "dplyr", "VGAM", "actuar"))

#
library(ggplot2)
library(dplyr)
```

### Quest√£o 1.

Escreva um algoritimo de simula√ß√£o para gerar uma valores

##### a) Distribui√ß√£o Bell-Touchard

A vari√°vel aleat√≥ria $X$ possui fun√ß√£o massa de probabilidade dada por:

$$
P(X = x) = \frac{e^{\theta (1 - e^{-\alpha})} \alpha^x T_x(\theta)}{x!}, \quad x = 0, 1, 2, \dots
$$

onde $T_x(\theta)$ s√£o os polin√¥mios de Touchard definidos por:

$$
T_x(\theta) = e^{-\theta} \sum_{k=0}^{\infty} \frac{k^x \theta^k}{k!}
$$

```{r, echo=TRUE}
# Passo 1: Fun√ß√£o para calcular o polin√¥mio de Touchard
tx <- function(x, theta, max_k = 500) {
  k <- 0:max_k
  somatorio <- (k^x) * (theta^k) / factorial(k)
  return(exp(-theta) * sum(somatorio))
}

# Passo 2: f(x) = P(X = x)
fx <- function(x, alpha, theta, max_x = 50) {
  Tx <- tx(x, theta)
  p1 <- exp(theta * (1 - exp(-alpha)))
  p2 <- (alpha^x) * Tx
  y <- (p1 * p2) / factorial(x)
  return(y)
}


alpha <- 2
theta <- 3/2
x <- 5

Tx <- tx(x, theta)
p1 <- exp(theta * (1 - exp(-alpha)))
p2 <- (alpha^x) * Tx
y <- (p1 * p2) / factorial(x)

cat("Tx:", Tx, "\n")
cat("p1:", p1, "\n")
cat("p2:", p2, "\n")
cat("fx(x):", y, "\n")


fx(5, 2, 3/2) # Erro, valores maiores que 1
sum(sapply(0:20, function(x) fx(x, 2, 3/2)))

# Passo 3: Metodo da invers√£o discreto
gerar_amostra <- function(alpha, theta, max_x = 50) {
  px <- purrr::map_dbl(0:max_x, ~ fx(.x, alpha, theta))
  Fx <- cumsum(px)
  u <- runif(1)
  x <- purrr::detect_index(Fx, ~ u <= .x) - 1
  return(x)
}

# Exemplo de uso
alpha <- 2
theta <- 3/2
max_x <- 20
n = 100
x <- purrr::map_int(1:n, ~ gerar_amostra(alpha, theta, max_x = max_x))

 
hist(x,
     main = "Histograma da Distribui√ß√£o Bell-Touchard",
     probability = TRUE
     ,col = "lightblue"
     )
curve(fx(x, alpha, theta), from = 0, to = max_x, col = "red", lwd = 1.5, , add = TRUE)
```

> O gr√°fico acima mostra a fun√ß√£o de massa de probabilidade da distribui√ß√£o Bell-Touchard para diferentes valores de $x$, com $\alpha = 1.0$ e $\theta = 2.0$.

##### b) Distribui√ß√£o *Kumaraswamy modificado*

A vari√°vel aleat√≥ria $Y$ possui fun√ß√£o densidade de probabilidade dada por:

$$
f(y; \alpha, \beta) = \frac{\alpha \beta e^{\alpha - \alpha/y} (1 - e^{\alpha - \alpha/y})^{\beta - 1}}{y^2}, \quad y \in (0,1).
$$

Usando o resultado da fun√ß√£o quantil, temos:

$$
F_Y(y)^{-1} = \frac{\alpha}{\alpha - log(1 - (1 - u)^{1/\beta})}
$$

```{r}
# Fun√ß√£o de densidade da Kumaraswamy modificada
# Defini√ß√£o da fun√ß√£o de densidade da Kumaraswamy modificada
fy <- function(y, alpha, beta) {
  (alpha * beta * exp(alpha - alpha / y) * (1 - exp(alpha - alpha / y))^(beta - 1)) / (y^2)
}

# 
y_KM <- function(N = 1000, alpha = 1, beta = 1) {
  u <- runif(N)
  y <- alpha / (alpha - log(1 - (1 - u)^(1/beta)))
  return(y)
}

# Par√¢metros
alpha <- 1
beta <- 1
N <- 10000

# Gera√ß√£o de amostras
y <- y_KM(N = N, alpha = alpha, beta = beta)
summary(y)

hist(y, 
     probability = TRUE,
     col = "lightblue",  
     main = paste("N =", length(y))
     )
curve(fy(x, alpha = 1, beta = 1), from = 0, to = 1, col = "red", lwd = 1.5, , add = TRUE)

```

### Quest√£o 2.

Use o m√©todo de Monte Carlo para estimar a seguinte integral:

$$
\int_{-\infty }^{\infty } \int_{0}^{2} \int_{0}^{\infty} ycos(\pi y) e^{-x^2y} e^{-yz} dz dy dx
$$ Como n√£o existe depend√™ncia entre as vari√°veis, podemos calcular a integral de forma separada.

```{r}
## g(x,y,z)
g <- function(x, y, z) {
  return(y * cos(pi * y) * exp(-x^2 * y) * exp(-y * z))
}

N <- 10000

# f(z)
z <- rexp(N)
f_z <- function(z) {
  z <- dexp(z)
  return(z)
}

# f(y)
y <- runif(N, 0, 2)
f_y <- function(y) {
  y <- dunif(y, 0, 2)
  return(y)
}

# f(x)
x <- rnorm(N)
f_x <- function(x) {
  x <- dnorm(x)
  return(x)
}

# h(x,y,z)
h = g(x, y, z)/(f_x(x) * f_y(y) * f_z(z))

# Estimativa da integral
est_I <- mean(h) |> round(4)

# Intervalo de confian√ßa a 98%
se <- sd(h) / sqrt(N)
z_crit <- qnorm(0.98)
IC <- c(est_I - z_crit * se, est_I + z_crit * se) |> round(4)


glue::glue("Estimativa da integral: {est_I} e considerando um intervalo de confian√ßa de 98%, temos: IC: ({IC[1]}, {IC[2]})")

```

### Quest√£o 3.

Experimento

```{r}
# Etapa 1.
set.seed(123)
n <- 25

resultados <- data.frame(
  cara = sample(c(0, 1), n, replace = TRUE, prob = c(1/3, 2/3)),
  bola = NA,
  valor = NA
)

# Etapa 2
resultados <- resultados |>
  rowwise() |>
  mutate(bola = if_else(
    cara == 1,
    sample(c("amarela", "azul"), 1, replace = TRUE, prob = c(3/5, 2/5)),
    sample(c("amarela", "azul"), 1, replace = TRUE, prob = c(2/6, 4/6))
  )) |>
  ungroup()

# Etapa 3
resultados <- resultados |>
  rowwise() |>
  mutate(valor = if_else(
    bola == "amarela",
    actuar::rztpois(1, lambda = 2),
    sum(VGAM::rbilogis(1, loc1 = 5, loc2 = 7, scale1 = 1, scale2 = exp(1)))
    )) |>
  ungroup()

resultados |> print()

```

#### Quest√£o 4. 

Seja ùëà \~ Uniforme 0,1 , use simula√ß√£o para aproximar $Corr(ùëà, \sqrt{(1‚àí ùëà^2)}$

```{r}
simular_cor <- function(n) {
# Estimativas das esperancas 
  U <- runif(n, min = 0, max = 1)
  r_U <- sqrt(1 - U^2)
  E_U_rU <- mean(U * r_U)      
  E_U <- mean(U)               
  E_rU <- mean(r_U)            
  
# Calcular a correla√ß√£p
  cov_U_rU <- E_U_rU - E_U * E_rU
  cor_U_rU <- cov_U_rU / (sd(U) * sd(r_U))
  cor_real <- cor(U, r_U)
  return(list('cor_est' = cor_U_rU, 'cor' = cor_real))
}

n <- 1000
resultado_simulacao <- simular_cor(n)
print(resultado_simulacao)
```
Acima est√£o os valores estimados da correla√ß√£o entre $U$ e $\sqrt{1 - U^2}$. Veja que para uma amostra de tamanho $n = 1000$, a correla√ß√£o estimada √© pr√≥xima da correla√ß√£o real.

# 

**Bom recesso!**

```{r}
# Fun√ß√£o para calcular o polin√¥mio de Touchard
# Adicionamos uma normaliza√ß√£o para evitar problemas num√©ricos
tx <- function(x, theta, max_k = 100) {
  k <- 0:max_k
  somatorio <- (k^x) * (theta^k) / factorial(k)
  return(exp(-theta) * sum(somatorio))
}

# Fun√ß√£o de massa de probabilidade da distribui√ß√£o Bell-Touchard
fx <- function(x, alpha, theta, max_x = 100) {
  if (x < 0 || floor(x) != x) return(0)  # Garantir que x seja inteiro e n√£o negativo
  
  Tx <- tx(x, theta, max_x)
  p1 <- exp(theta * (1 - exp(-alpha)))
  p2 <- (alpha^x) * Tx / factorial(x)
  y <- p1 * p2
  
  # Normaliza para garantir que seja uma fdp
  normalizador <- sum(sapply(0:max_x, function(i) {
    Tx_i <- tx(i, theta, max_x)
    (exp(theta * (1 - exp(-alpha))) * (alpha^i * Tx_i)) / factorial(i)
  }))
  
  return(y / normalizador)
}

# Teste para garantir que a soma seja aproximadamente 1
soma_fdp <- sum(sapply(0:50, function(x) fx(x, 2, 3/2)))
cat("Soma da fdp:", soma_fdp, "\n")

```

